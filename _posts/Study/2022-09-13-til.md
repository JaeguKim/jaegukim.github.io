---
layout: post
title: "TIL"
date: 2022-09-13 14:17:00 +0900
categories: [Study]
---

## 2022-09-13
- `new(T)` vs `Make(T)`
    - `new(T)` allocates zeroed storage for a new item of type T and returns its address as a value of type *T
    - `make(T)` returns an initialized value of type T.
    - For slices, maps and channels: use `make`
    - For arrays, structs and all value types: use  `new`
- Go Best practices
    - value type에 대한 pointer를 misuse하지 말기, 이는 stack에 있는 값을 heap영역으로 복사하게 되면서 추가적으로 메모리 할당이 일어나게 된다.
- 변수이름은 구현체가 안드러나도록, 추상화레벨에 맞추는것이 좋다.(eg. redisPubSub대신 그것을 추상화한 broadcastQueue)
- sync.map vs map + mutex
    - sync.map : 동기화에 대한 부담이 줄어들지만 key,value의 타입을 명시적으로 선언해주지 못한다는 단점존재
    - map과 mutex 사용 : key,value의 타입을 명시적으로 지정가능, 동기화에 대한 부담 가중

## 2022-09-16
- 코드 리뷰중 배운사항
    - 새로운 파일을 git에 추가시, 파일의 맨마지막에 newline을 반드시 추가하는것이 컨벤션이다. 이렇게 해야하는 이유는 다음에 파일을 수정할때 newline을 입력하면서 diff에 newline입력부분이 포함되어 지저분해지기 때문이다. GoLand에서는 파일 저장시 자동으로 newline을 삽입하도록 설정할수 있다.(2022.2 버전기준으로 Preferences -> Editor -> General -> OnSave 하단에 Ensure every file ends with a line break)
    - 윈도우에서는 newline문자를 crlf를 사용하고 unix/linux에서는 lf를 사용한다. 만약 윈도우에서 작업한 파일을 클론하여 수정하면 crlf 문자를 lf로 변환하는 불필요한 diff가 발생하게 된다. 이를 해결하기 위해서 `core.autocrlf` 설정을 세팅해야 한다. 아래와 같은 옵션이 있는데 mac의 경우 input으로 설정하고 windows의 경우 true로 설정해야 한다.
        - core.autocrlf = false. 기본 설정이다. 파일에 CRLF 를 썼든 LF 를 썼든 git 은 상관하지 않고 파일 그대로 checkin, checkout 한다. 이 설정은 line ending 이 다른 OS 에서는 text file 이 변경되었다고 나오므로 위에서 언급한 여러 가지 문제가 발생할 수 있다.
        - core.autocrlf = true text file을 object database 에 넣기전에 CRLF 를 LF 로 변경한다.
        - core.autocrlf = input LF를 line ending 으로 사용한다.
    - git commit 메시지 작성요령 : `https://meetup.toast.com/posts/106`
        - 여기서 명령형으로 하는 이유가 git에서 자동생성된 커밋과 위화감 없게 하기위함 이라니 신기했다.
        - 커밋 메시지의 첫문자는 항상 대문자, 명령형으로 시작하기!
- 동료의 개발환경 세팅을 도와주던중 `protoc output: protoc error: fork/exec /usr/local/bin/protoc: exec format error` 라는 에러를 보게되었는데 이것을 보고 protoc 실행에 문제가 있다고 의심을 했어야 했다. 그런데 m1 mac이라서 protoc가 제대로 동작하지 않을거라고 망상했다. 소경이 소경을 인도할수는 없다. 항상 글자 그대로 받아들이는 연습을 해야겠다.
- context.Context 패키지 cancelFunc 함수가 여러번 호출되는 경우, 어떻게 동작할까 궁금해서 구글링을 먼저했는데 답이 잘 나오지 않았다. 내부 코드에 있는 주석을 보고나서 바로 파악할 수 있었다. 항상 쉬운 방법을 고집할것이 아니라 가장 정석적인 방법도 염두에 두어야 겠다.

### Go lang에서 파라미터에 인터페이스 타입을 포인터로 정의해둘지 여부에 대한 따른 고찰
- 일반적으로 인터페이스 타입을 포인터 타입으로 정의해둘 필요는 거의 없다.
- 파라미터로 넘길 struct에서 value 리시버로 메소드를 정의해둔 경우 값으로 넘기든 포인터로 넘기든 상관없다.
- 반면 포인터 리시버로 메소드를 정의해둔 경우, 함수 파라미터 타입이 값 인터페이스 타입이더라도 반드시 struct의 주소를 넘기도록 강제하고 있다.

``` go
package main

type Iface interface {
    foo()
}

var _ Iface = (*Impl1)(nil)

type Impl1 struct {
    mp map[string]string
}

func (i Impl1) foo() {

}

var _ Iface = (*Impl2)(nil)

type Impl2 struct {
    mp map[string]string
}

func (i *Impl2) foo() {

}

func baz() {
    i1 := Impl1{}
    boo(i1)
    boo(&i1)

    i2 := Impl2{}
    boo(i2) // compile error가 난다.
    boo(&i2)
}

func boo(iface Iface) Iface {
    _ = iface
}
```

- slice의 경우 새로운 아이템을 추가할때 새로운 array가 할당되는데, 같은 array가 할당되게 하려면 아래 두가지 방법을 사용할수 있다.

``` go
func foo1(s *[]string) {
    *s = append(*s, "ss")
}

func foo2(s []string) []string {
    return append(s, "ss")
}
```


## 2022-09-15
- GoLand에서 code inspection 기능을 사용하면 채널 close나 context.cancel() 함수 처럼 빠뜨리기 쉬운 작업들이 제대로 되었는가 체크할수 있다.
- go의 convention상 context.Context 타입의 입력 파라미터는 항상 맨 앞에 와야하고 error 타입의 파라미터는 맨뒤에 와야 한다.

## 2022-09-21
- error 로그를 찍을때 상세한 정보 추가하기
- grpc에서 클라이언트로 에러를 내려줄때 응답코드 내려주기
- grpc 핸들러에서 코드는 ans struct 생성, 작업, 결과 리턴 패턴으로 작성

## 2022-09-23

### blocking vs non-blocking
- Blocking
    - A 함수가 B 함수를 호출 할 때, B 함수가 자신의 작업이 종료되기 전까지 A 함수에게 제어권을 돌려주지 않는 것
- Non-blocking
    - A 함수가 B 함수를 호출 할 때, B 함수가 제어권을 바로 A 함수에게 넘겨주면서, A 함수가 다른 일을 할 수 있도록 하는 것.

### Synchronous vs Asynchronous
- Synchronous
    - A 함수가 B 함수를 호출 할 때, B 함수의 결과를 A 함수가 처리하는 것.
- Asynchronous
    - A 함수가 B 함수를 호출 할 때, B 함수의 결과를 B 함수가 처리하는 것.

## 2022-09-30
- server repo pr 올릴때 관련된 다른 pr 링크도 description에 명시할것
- 영역구분 등과 같이 의미가 적은 주석 사용하지 않기
- 추후에 수정해야하는 부분은 `TODO`, `FIXME`로 시작하는 코멘트 추가 또는 해당 라인에 pr comment 달기
- RWLock의 경우, Reader가 락을 잡고 있는 동안 다른 Reader가 CS에 진입이 가능하고 다른 Writer는 Reader가 unlock할때까지 대기한다. Writer가 락을 잡으면 그 동안 Reader는 대기한다.([참고](https://medium.com/golangspec/sync-rwmutex-ca6c6c3208a0))

## 2022-10-24
- Go에서 pointer interface 타입은 사용하지 않는다. 인터페이스 타입은 인터페이스에 저장된 타입정보에 대한 포인터와 연관된 데이터에 대한 포인터를 저장하기 때문이다. [참고](https://stackoverflow.com/a/13511853/8276700)

## 2022-11-08
- Fake, mock, stub 차이점
    - Fake object : 실제로 동작하는 구현이지만 production에는 suitable하지 않은 것입니다.
    - Mock object : 실제 객체를 모방하여 테스트용으로 작성한 특수 케이스 객체
    - Stub : 미리 준비된 응답만 제공하기 위해 테스트용으로 작성한 것. 즉, 반환값만 맞춰 준 것.
    - Spy : Stub이긴 한데 호출 방식에 따른 정보 기록(record) 까지 수행
- [Uber Go Style Guide](https://github.com/uber-go/guide/blob/master/style.md#test-tables)

## 2022-11-11
- Mac 업데이트후 몇몇 프로그램 설치가 안되있는경우 설치방법
    - diff 설치 : `brew install diffutils`
    - realpath 설치 : `brew install coreutils`

## 2022-11-14
- Makefile시 .PHONY 사용하는 이유
  - target과 실제 파일 이름이 동일할시 기본은 파일에 있는 커멘드를 실행한다. 하지만 .PHONY에 명시할경우 target이 실행된다.
  - 하위 make에서 에러가 발생할때 커멘드를 중지, 커멘드를 병렬로 실행할수 있도록 제공
- Mac에서 구름입력기 설치하여 폰트 한글 입력속도 개선하기
  - https://github.com/gureum/gureum/wiki/Help-Install
- Unix File Permissions
  - 1번째 비트 : 디렉토리면 "d" 아니면 "-"
  - 2,3,4번째 비트 : file의 user(owner)에 대한 read,write,execute permission
  - 5,6,7번째 비트 : group에 대한 read,write,execute permission
  - 8,9,10번째 비트 : other(world)에 대한 read,write,execute permission

## 2022-12-06
### Go에서 map을 초기화할때 가능하면 아래와 같이 capacity hint를 제공하는것이 좋다.
```go
make(map[T1]T2, hint)
```
slice와 달리 complete, preemptive allocation을 보장해주지는 못하지만 필요한 hashmap bucket의 수를 approximate하는데 사용된다.
### Slice을 초기화할때 Capacity를 가능하면 명시하기
capacity를 명시해두면 compiler가 slice capacity를 위한 충분한 메모리를 할당해주며, slice 길이가 capacity에 도달하기 전까지는 연속적인 append작업시 추가적인 메모리 할당을 유발하지않는다.

## 2022-12-07
- - [Uber Go Style Guide](https://github.com/uber-go/guide/blob/master/style.md#test-tables) 문서를 1회독 했다. 주기적으로 읽으면 좋을것같다.
